// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

namespace Microsoft.Quantum.QsCompiler.TargetGeneration

open Microsoft.CodeAnalysis.CSharp.Syntax

open Microsoft.Quantum.RoslynWrapper

open System.Collections.Generic
open System.IO
open Microsoft.Quantum.QsCompiler.CsharpGeneration
open Microsoft.Quantum.QsCompiler.SyntaxTree
open Microsoft.Quantum.QsCompiler.SyntaxTokens

module GenerateTarget =
    let private autoNamespaces =
        [
            "System"
            "Microsoft.Quantum.Core"
            "Microsoft.Quantum.Intrinsic"
            "Microsoft.Quantum.Simulation.Core"
        ]

    /// The comment that is displayed at the top of generated files.
    let private autogenComment = [
        "//------------------------------------------------------------------------------"
        "// <auto-generated>                                                             "
        "//     This code was generated by a tool.                                       "
        "//     Changes to this file may cause incorrect behavior and will be lost if    "
        "//     the code is regenerated.                                                 "
        "// </auto-generated>                                                            "
        "//------------------------------------------------------------------------------"
    ]

    // Builds the top-level compilation unit structure
    let private buildHeader (baseClassOpt : string option) ns =
        let namespaces = match baseClassOpt  with
                         | Some s -> s.Substring(0, s.LastIndexOf('.')) :: autoNamespaces
                         | None -> autoNamespaces
        let usings = namespaces |> List.map (fun ns -> ``using`` ns)

        ``compilation unit``
            []
            usings
            [ns]
        // We add a "pragma warning disable 1591" since we don't generate doc comments in our C# code.
        |> ``pragmaDisableWarning`` 1591
        |> ``pragmaDisableWarning`` 0162 // unreachable code
        |> ``pragmaDisableWarning`` 0436 // shadowing existing classes from references
        |> ``with leading comments`` autogenComment

    let private buildNamespace name target =
        ``namespace`` name
            ``{``
                []
                [target]
            ``}``

    let private buildClass targetClass targetBaseClass members = 
        let baseClass = match targetBaseClass with | Some s -> s | None -> "SimulatorBase"
                        |> simpleBase |> Some
        ``class`` targetClass ``<<`` [] ``>>`` ``:`` baseClass ``,`` [] [``abstract``; ``public``] ``(`` members ``)``

    let private buildImplMethod context args (sp : QsSpecialization) =
        let outType = SimulationCode.roslynTypeName context sp.Signature.ReturnType
        match sp.Implementation with
        | Generated SelfInverse -> Seq.empty
        | _ ->
            let implName = "Do" + sp.Parent.Name.Value + match sp.Kind with
                                                            | QsBody              -> ""
                                                            | QsAdjoint           -> "Adj"
                                                            | QsControlled        -> "Ctl"
                                                            | QsControlledAdjoint -> "CtlAdj"
            let parms = args |> List.map (fun (n, t) -> ``param`` n ``of`` (``type`` t))
            let impl = ``method`` outType implName ``<<`` [] ``>>`` 
                            ``(`` parms ``)`` [``public``;``abstract``]
                            ``{`` [] ``}`` :> MemberDeclarationSyntax
            seq { impl }

    let buildImplProperty context args (subclass : MemberDeclarationSyntax) (sp : QsSpecialization) =
        let generateSelfCall (name : string) =
            let selfName = name.Replace("Adjoint", "")
            ``ident`` selfName
        let inType  = SimulationCode.roslynTypeName context sp.Signature.ArgumentType
        let outType = SimulationCode.roslynTypeName context sp.Signature.ReturnType
        let propertyType = "Func<" + inType + ", " + outType + ">"
        let propertyName =
            match sp.Kind with
            | QsBody              -> "Body"
            | QsAdjoint           -> "AdjointBody"
            | QsControlled        -> "ControlledBody"
            | QsControlledAdjoint -> "ControlledAdjointBody"
        let propertyImpl = match sp.Implementation with
                           | Generated SelfInverse -> generateSelfCall propertyName |> ignore
                           | _ -> ()
        ()

    let buildSpecializationMethods context (subclass : MemberDeclarationSyntax) args (sp : QsSpecialization) =
        let inType  = SimulationCode.roslynTypeName context sp.Signature.ArgumentType
        let outType = SimulationCode.roslynTypeName context sp.Signature.ReturnType
        let propertyType = "Func<" + inType + ", " + outType + ">"
        let bodyName =
            match sp.Kind with
            | QsBody              -> "Body"
            | QsAdjoint           -> "Adjoint"
            | QsControlled        -> "Controlled"
            | QsControlledAdjoint -> "ControlledAdjoint"
        let impl = buildImplMethod context args sp
        buildImplProperty context args subclass sp
        impl

    // Builds the implementing methods in the subclass and for the main class
    let private buildSubclassMethods context (op : QsCallable) (subclass : MemberDeclarationSyntax) =
        let args = SimulationCode.flatArgumentsList context op.ArgumentTuple
        op.Specializations |> Seq.collect (buildSpecializationMethods context subclass args)

    let buildIntrinsic context intrinsic : MemberDeclarationSyntax seq =
        let subclass = SimulationCode.buildOperationClass context intrinsic
        Seq.append (buildSubclassMethods context intrinsic subclass) (seq { subclass })

    let private namespaceElementIsIntrinsic elem =
        match elem with
        | QsCallable callable -> 
            match callable.Kind with
            | TypeConstructor -> None
            | _ -> 
                if callable.Specializations 
                   |> Seq.exists (fun spec -> match spec.Implementation with
                                                    | SpecializationImplementation.Intrinsic -> true
                                                    | _ -> false)
                then Some callable
                else None
        | _ -> None

    let private findIntrinsics syntaxTree =
        syntaxTree 
        |> Seq.collect (fun ns -> ns.Elements |> Seq.choose namespaceElementIsIntrinsic)

    let GenerateTarget (syntaxTree : QsNamespace seq) outputFile targetClass targetNamespace targetBaseClass =
        let context = CodegenContext.Create(syntaxTree, new Dictionary<string, string>())
        let intrinsics = syntaxTree |> findIntrinsics
        let members = intrinsics |> Seq.collect (buildIntrinsic context)
        let target = buildClass targetClass targetBaseClass members
        let ns = buildNamespace targetNamespace target
        let syntax = buildHeader targetBaseClass ns
        let text = syntax |> SimulationCode.formatSyntaxTree
        File.WriteAllText(outputFile, text)
